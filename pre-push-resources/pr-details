#!/bin/bash
#
# post-push hook to generate PR details using Gemini API.
#
# To enable this hook, make it executable:
# chmod +x .git/hooks/post-push

# ============================================================================
# CONFIGURATION - MODIFY THESE VALUES
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RESOURCES_DIR="$SCRIPT_DIR"
INI_FILE="$RESOURCES_DIR/gemini.ini"

# Read API key and URL from gemini.ini
GEMINI_API_KEY=$(grep -E '^api_key\s*=' "$INI_FILE" | sed -e 's/api_key\s*=\s*//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
GEMINI_API_URL=$(grep -E '^api_url\s*=' "$INI_FILE" | sed -e 's/api_url\s*=\s*//' -e 's/^[[:space:]]*$//')

# Path to the prompt template file (relative to the script directory)
PROMPT_TEMPLATE_FILE="$RESOURCES_DIR/prompt_templates/pr_details_prompt_template.txt"

# ============================================================================
# LOGGING CONFIGURATION
# ============================================================================

# Color codes for better log visibility
COLOR_RESET='\033[0m'
COLOR_INFO='\033[0;36m'      # Cyan
COLOR_SUCCESS='\033[0;32m'   # Green
COLOR_WARNING='\033[0;33m'   # Yellow
COLOR_ERROR='\033[0;31m'     # Red
COLOR_DEBUG='\033[0;90m'     # Gray

# Log functions
log_info() {
    echo -e "${COLOR_INFO}[INFO]${COLOR_RESET} $1" >&2
}

log_success() {
    echo -e "${COLOR_SUCCESS}[SUCCESS]${COLOR_RESET} $1" >&2
}

log_warning() {
    echo -e "${COLOR_WARNING}[WARNING]${COLOR_RESET} $1" >&2
}

log_error() {
    echo -e "${COLOR_ERROR}[ERROR]${COLOR_RESET} $1" >&2
}

log_debug() {
    echo -e "${COLOR_DEBUG}[DEBUG]${COLOR_RESET} $1" >&2
}

log_section() {
    echo "" >&2
    echo -e "${COLOR_INFO}════════════════════════════════════════════════════════════════${COLOR_RESET}" >&2
    echo -e "${COLOR_INFO}  $1${COLOR_RESET}" >&2
    echo -e "${COLOR_INFO}════════════════════════════════════════════════════════════════${COLOR_RESET}" >&2
}

# ============================================================================
# FUNCTIONS
# ============================================================================

# Function to check if required tools are available
check_dependencies() {
    log_info "Checking dependencies..."

    if ! command -v curl >/dev/null 2>&1; then
        log_error "curl is required but not installed"
        exit 1
    fi
    log_debug "curl: ✓ Found"

    if ! command -v jq >/dev/null 2>&1; then
        log_warning "jq is not installed - JSON response formatting will be limited"
    else
        log_debug "jq: ✓ Found"
    fi
}

# Function to escape JSON strings
escape_json() {
    local input="$1"
    # Escape backslashes, quotes, and newlines for JSON
    echo "$input" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g'
}

# Function to call Gemini API
call_gemini_api() {
    local prompt="$1"
    local temp_response="/tmp/gemini_pr_response_$$.json"
    local temp_payload="/tmp/gemini_pr_payload_$$.json"

    log_info "Calling Gemini API for PR details generation..."
    log_debug "Using model: gemini-2.5-pro"

    # Escape the prompt for JSON
    local escaped_prompt
    escaped_prompt=$(escape_json "$prompt")

    # Create JSON payload
    cat > "$temp_payload" <<EOF
{
  "contents": [
    {
      "parts": [
        {
          "text": "$escaped_prompt"
        }
      ]
    }
  ]
}
EOF

    log_debug "Payload size: $(wc -c < "$temp_payload") bytes"

    # Make API call to Gemini
    local start_time=$(date +%s)
    curl -s -X POST \
        -H "Content-Type: application/json" \
        -d @"$temp_payload" \
        "$GEMINI_API_URL?key=$GEMINI_API_KEY" \
        > "$temp_response"

    local curl_exit_code=$?
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    rm -f "$temp_payload"

    if [ $curl_exit_code -ne 0 ]; then
        log_error "Failed to call Gemini API (curl exit code: $curl_exit_code)"
        rm -f "$temp_response"
        return 1
    fi

    log_debug "API response received in ${duration}s"

    # Extract text from response
    if command -v jq >/dev/null 2>&1; then
        local response_text
        response_text=$(jq -r '.candidates[0].content.parts[0].text // "Error: No response text found"' "$temp_response" 2>/dev/null)
        if [ "$response_text" != "null" ] && [ "$response_text" != "Error: No response text found" ]; then
            log_success "Successfully received PR details response"
            echo "$response_text"
        else
            log_error "Unable to parse Gemini API response"
            log_debug "Response content:"
            cat "$temp_response" >&2
            rm -f "$temp_response"
            return 1
        fi
    else
        # Fallback if jq is not available - try basic text extraction
        local response_content
        response_content=$(cat "$temp_response")
        log_warning "jq not available - showing raw API response"
        echo "$response_content" >&2
    fi

    rm -f "$temp_response"
    return 0
}

# Function to load prompt template from external file
load_prompt_template() {
    if [ ! -f "$PROMPT_TEMPLATE_FILE" ]; then
        log_error "Prompt template file not found at: $PROMPT_TEMPLATE_FILE"
        log_error "Make sure the pr_details_prompt_template.txt file exists in the hooks directory"
        exit 1
    fi

    log_debug "Loading prompt template from: $PROMPT_TEMPLATE_FILE"
    cat "$PROMPT_TEMPLATE_FILE"
}

# Function to generate PR details from diff content
generate_pr_details() {
    local diff_content="$1"
    local branch_name="$2"

    # Load the prompt template from external file
    log_info "Loading PR details prompt template..."
    PR_DETAILS_PROMPT=$(load_prompt_template)

    # Create the full prompt
    FULL_PROMPT="The git diff is:


    $diff_content


    $PR_DETAILS_PROMPT"

    # Call Gemini API
    PR_DETAILS_RESULT=$(call_gemini_api "$FULL_PROMPT")

    if [ $? -ne 0 ]; then
        log_error "Failed to generate PR details"
        return 1
    fi

    # Save the result to a markdown file
    FILENAME="PR_DETAILS_$(echo $branch_name | sed 's/\//_/g')_$(date +%Y%m%d%H%M%S).md"
    echo "$PR_DETAILS_RESULT" > "$FILENAME"

    log_success "PR details saved to: $FILENAME"
    return 0
}

# Determine the base branch according to the branch naming convention.
get_env_base_branch() {
    local branch_name="$1"

    if [[ "$branch_name" == *"/ci/"* ]]; then
        echo "master"
    elif [[ "$branch_name" == *"/dev/"* ]]; then
        echo "development"
    elif [[ "$branch_name" == *"/release/"* ]]; then
        echo "release"
    else
        echo ""
    fi
}

# Resolve a branch name to a ref that exists locally (or on origin).
resolve_branch_ref() {
    local branch="$1"

    if [ -z "$branch" ]; then
        return 1
    fi

    if git rev-parse --verify --quiet "$branch" >/dev/null 2>&1; then
        echo "$branch"
        return 0
    fi

    if git rev-parse --verify --quiet "origin/$branch" >/dev/null 2>&1; then
        echo "origin/$branch"
        return 0
    fi

    return 1
}

# ============================================================================
# MAIN LOGIC
# ============================================================================

# Check if SKIP_PR_DETAILS flag is set
if [ "${SKIP_PR_DETAILS:-false}" = true ]; then
    log_info "SKIP_PR_DETAILS flag detected - skipping PR details generation"
    exit 0
fi

log_section "PR DETAILS GENERATION"

# Check if API key is configured
if [ -z "$GEMINI_API_KEY" ]; then
    log_error "Could not read GEMINI_API_KEY from gemini.ini"
    log_error "Please ensure gemini.ini exists in $RESOURCES_DIR and contains 'api_key = your-key'"
    exit 1
fi

log_success "API key configured"

# Check dependencies
check_dependencies

# Check if we're being called from pre-push hook (with stdin) or standalone
# Read from stdin (if available from pre-push hook)
refs_input=$(cat)

if [ -n "$refs_input" ]; then
    log_debug "Processing refs from pre-push hook stdin"

    # Process refs from stdin (traditional post-push behavior)
    processed_count=0
    while read local_ref local_sha remote_ref remote_sha; do
        # Skip empty lines
        if [ -z "$local_ref" ]; then
            continue
        fi

        log_debug "Processing ref: $local_ref ($local_sha -> $remote_sha)"

        # We only care about branches, not tags
        if [[ $local_ref != refs/heads/* ]]; then
            log_debug "Skipping non-branch ref: $local_ref"
            continue
        fi

        # Get the range of commits that were pushed
        # If the remote branch was deleted, we can't get a diff
        if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
            log_warning "Branch was deleted, skipping"
            continue
        fi

        # If the remote branch is new, diff against the parent of the first commit
        if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
            remote_sha=$(git rev-parse $local_sha^1 2>/dev/null)
            log_info "New branch detected, comparing against parent commit"
        fi

        # Get branch name for logging and filename purposes
        BRANCH_NAME=$(echo "$local_ref" | sed 's/refs\/heads\///')

        BASE_BRANCH_NAME=$(get_env_base_branch "$BRANCH_NAME")
        BASE_BRANCH_REF=""
        if [ -n "$BASE_BRANCH_NAME" ]; then
            if BASE_BRANCH_REF=$(resolve_branch_ref "$BASE_BRANCH_NAME" 2>/dev/null); then
                log_info "Branch '$BRANCH_NAME' uses base '$BASE_BRANCH_NAME' - comparing against $BASE_BRANCH_REF"
            else
                log_warning "Base branch '$BASE_BRANCH_NAME' not found locally - falling back to push range"
                BASE_BRANCH_REF=""
            fi
        fi

        if [ -n "$BASE_BRANCH_REF" ]; then
            log_info "Generating diff for range: $BASE_BRANCH_REF..${local_sha:0:8}"
            DIFF_CONTENT=$(git diff "$BASE_BRANCH_REF" "$local_sha" 2>/dev/null)
        else
            log_info "Generating diff for range: ${remote_sha:0:8}..${local_sha:0:8}"
            DIFF_CONTENT=$(git diff "$remote_sha" "$local_sha" 2>/dev/null)
        fi

        if [ -z "$DIFF_CONTENT" ]; then
            log_warning "No changes detected in this push - skipping PR details generation"
            continue
        fi

        # Generate PR details
        generate_pr_details "$DIFF_CONTENT" "$BRANCH_NAME"
        ((processed_count++))
    done <<< "$refs_input"

    if [ $processed_count -eq 0 ]; then
        log_warning "No valid refs were processed from stdin"
    else
        log_section "PR DETAILS GENERATION COMPLETED"
        log_success "Total files generated: $processed_count"
    fi
else
    # Called standalone or from pre-push without refs - use current commit
    log_debug "No stdin input detected - using current HEAD commit"

    # Verify we have a valid commit
    if ! git rev-parse --verify HEAD >/dev/null 2>&1; then
        log_warning "No commits available for PR details generation"
        exit 0
    fi

    CURRENT_COMMIT=$(git rev-parse HEAD)
    BRANCH_NAME=$(git branch --show-current 2>/dev/null || echo "detached")

    log_info "Generating PR details for current commit: ${CURRENT_COMMIT:0:8}"
    log_info "Branch: $BRANCH_NAME"

    BASE_BRANCH_NAME=$(get_env_base_branch "$BRANCH_NAME")
    BASE_BRANCH_REF=""
    if [ -n "$BASE_BRANCH_NAME" ]; then
        if BASE_BRANCH_REF=$(resolve_branch_ref "$BASE_BRANCH_NAME" 2>/dev/null); then
            log_info "Branch '$BRANCH_NAME' uses base '$BASE_BRANCH_NAME' - comparing against $BASE_BRANCH_REF"
        else
            log_warning "Base branch '$BASE_BRANCH_NAME' not found locally - continuing with default comparison"
            BASE_BRANCH_REF=""
        fi
    fi

    # Try to get remote tracking branch
    REMOTE_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)

    if [ -n "$BASE_BRANCH_REF" ]; then
        log_info "Comparing against resolved base branch: $BASE_BRANCH_REF"
        DIFF_CONTENT=$(git diff "$BASE_BRANCH_REF" "$CURRENT_COMMIT")
    elif [ -n "$REMOTE_BRANCH" ]; then
        # Diff against remote tracking branch
        log_info "Comparing against remote tracking branch: $REMOTE_BRANCH"
        DIFF_CONTENT=$(git diff "$REMOTE_BRANCH" HEAD)
    else
        # Fallback to parent commit
        log_info "No remote tracking branch found - comparing against parent commit"
        PARENT_COMMIT=$(git rev-parse HEAD^1 2>/dev/null)
        if [ -n "$PARENT_COMMIT" ]; then
            DIFF_CONTENT=$(git diff "$PARENT_COMMIT" HEAD)
        else
            # Initial commit - diff against empty tree
            EMPTY_TREE=$(git hash-object -t tree /dev/null)
            DIFF_CONTENT=$(git diff "$EMPTY_TREE" HEAD)
        fi
    fi

    if [ -z "$DIFF_CONTENT" ]; then
        log_warning "No changes detected - skipping PR details generation"
        exit 0
    fi

    # Generate PR details
    generate_pr_details "$DIFF_CONTENT" "$BRANCH_NAME"

    log_section "PR DETAILS GENERATION COMPLETED"
    log_success "File generated successfully"
fi
