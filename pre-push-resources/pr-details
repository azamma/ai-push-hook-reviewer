#!/bin/bash
#
# post-push hook to generate PR details using Gemini API.
#
# To enable this hook, make it executable:
# chmod +x .git/hooks/post-push

# ============================================================================
# CONFIGURATION - MODIFY THESE VALUES
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RESOURCES_DIR="$SCRIPT_DIR"
AI_MODELS_CONFIG="$RESOURCES_DIR/ai-models.yml"

# Model selection (default: 1=Gemini, can be overridden with MODEL env variable)
MODEL=${MODEL:-1}

# Parse YAML model configuration using bash + awk (no external deps)
parse_yaml_model() {
    local model_id="$1"
    local config_file="$2"
    local key="$3"

    # Find the model block and extract the key value
    awk -v id="$model_id" -v k="$key" '
        /^models:/ { in_models=1; next }
        in_models && /^  - id: / {
            current_id=$NF
            if (current_id == id) { found=1 }
        }
        found && /^  - id: / && current_id != id { found=0 }
        found && $0 ~ "^    " k ": " {
            # Extract value after the key
            match($0, /^    [^:]+: (.*)$/, arr)
            gsub(/["'"'"']/, "", arr[1])  # Remove quotes
            print arr[1]
            exit
        }
    ' "$config_file"
}

# Load model configuration from YAML
load_model_config() {
    local model_num="$1"

    if [ ! -f "$AI_MODELS_CONFIG" ]; then
        log_error "Model configuration file not found at: $AI_MODELS_CONFIG"
        exit 1
    fi

    # Parse YAML for model details
    local model_type
    local model_config_file
    local response_parser

    model_type=$(parse_yaml_model "$model_num" "$AI_MODELS_CONFIG" "type")
    model_config_file=$(parse_yaml_model "$model_num" "$AI_MODELS_CONFIG" "config_file")
    response_parser=$(parse_yaml_model "$model_num" "$AI_MODELS_CONFIG" "response_parser")

    if [ -z "$model_type" ] || [ -z "$model_config_file" ]; then
        log_error "Model $model_num not found in configuration"
        exit 1
    fi

    local model_ini_file="$RESOURCES_DIR/$model_config_file"

    if [ ! -f "$model_ini_file" ]; then
        log_error "Model config file not found at: $model_ini_file"
        exit 1
    fi

    echo "$model_ini_file:$model_type:$response_parser"
}

# Get model configuration
MODEL_CONFIG=$(load_model_config "$MODEL")
MODEL_INI_FILE="${MODEL_CONFIG%%:*}"
MODEL_TYPE="${MODEL_CONFIG#*:}"
MODEL_TYPE="${MODEL_TYPE%%:*}"
RESPONSE_PARSER="${MODEL_CONFIG##*:}"

log_debug "Using MODEL=$MODEL ($MODEL_TYPE)"

# Read API key and URL from the selected model config
API_KEY=$(grep -E '^api_key\s*=' "$MODEL_INI_FILE" | sed -e 's/api_key\s*=\s*//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
API_URL=$(grep -E '^api_url\s*=' "$MODEL_INI_FILE" | sed -e 's/api_url\s*=\s*//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

# Path to the prompt template file (relative to the script directory)
PROMPT_TEMPLATE_FILE="$RESOURCES_DIR/prompt_templates/pr_details_prompt_template.txt"

# ============================================================================
# LOGGING CONFIGURATION
# ============================================================================

# Color codes for better log visibility
COLOR_RESET='\033[0m'
COLOR_INFO='\033[0;36m'      # Cyan
COLOR_SUCCESS='\033[0;32m'   # Green
COLOR_WARNING='\033[0;33m'   # Yellow
COLOR_ERROR='\033[0;31m'     # Red
COLOR_DEBUG='\033[0;90m'     # Gray

# Log functions
log_info() {
    echo -e "${COLOR_INFO}[INFO]${COLOR_RESET} $1" >&2
}

log_success() {
    echo -e "${COLOR_SUCCESS}[SUCCESS]${COLOR_RESET} $1" >&2
}

log_warning() {
    echo -e "${COLOR_WARNING}[WARNING]${COLOR_RESET} $1" >&2
}

log_error() {
    echo -e "${COLOR_ERROR}[ERROR]${COLOR_RESET} $1" >&2
}

log_debug() {
    echo -e "${COLOR_DEBUG}[DEBUG]${COLOR_RESET} $1" >&2
}

log_section() {
    echo "" >&2
    echo -e "${COLOR_INFO}════════════════════════════════════════════════════════════════${COLOR_RESET}" >&2
    echo -e "${COLOR_INFO}  $1${COLOR_RESET}" >&2
    echo -e "${COLOR_INFO}════════════════════════════════════════════════════════════════${COLOR_RESET}" >&2
}

# ============================================================================
# FUNCTIONS
# ============================================================================

# Function to check if required tools are available
check_dependencies() {
    log_info "Checking dependencies..."

    if ! command -v curl >/dev/null 2>&1; then
        log_error "curl is required but not installed"
        exit 1
    fi
    log_debug "curl: ✓ Found"

    if ! command -v jq >/dev/null 2>&1; then
        log_warning "jq is not installed - JSON response formatting will be limited"
    else
        log_debug "jq: ✓ Found"
    fi
}

# Function to escape JSON strings
escape_json() {
    local input="$1"
    # Escape backslashes, quotes, and newlines for JSON
    echo "$input" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g'
}

# Function to call AI API (Gemini or Deepseek)
call_ai_api() {
    local prompt="$1"
    local temp_response="/tmp/ai_pr_response_$$.json"
    local temp_payload="/tmp/ai_pr_payload_$$.json"

    log_info "Calling $MODEL_TYPE API for PR details generation..."
    log_debug "Using model type: $MODEL_TYPE"

    # Escape the prompt for JSON
    local escaped_prompt
    escaped_prompt=$(escape_json "$prompt")

    if [ "$MODEL_TYPE" = "gemini" ]; then
        # Gemini API format
        log_debug "Using Gemini format"
        cat > "$temp_payload" <<EOF
{
  "contents": [
    {
      "parts": [
        {
          "text": "$escaped_prompt"
        }
      ]
    }
  ]
}
EOF

        log_debug "Payload size: $(wc -c < "$temp_payload") bytes"

        # Make API call to Gemini
        local start_time=$(date +%s)
        curl -s -X POST \
            -H "Content-Type: application/json" \
            -d @"$temp_payload" \
            "$API_URL?key=$API_KEY" \
            > "$temp_response"

        local curl_exit_code=$?
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        rm -f "$temp_payload"

        if [ $curl_exit_code -ne 0 ]; then
            log_error "Failed to call $MODEL_TYPE API (curl exit code: $curl_exit_code)"
            rm -f "$temp_response"
            return 1
        fi

        log_debug "API response received in ${duration}s"

        # Extract text from response using dynamic parser
        if command -v jq >/dev/null 2>&1; then
            local response_text
            response_text=$(jq -r "$RESPONSE_PARSER // \"Error: No response text found\"" "$temp_response" 2>/dev/null)
            if [ "$response_text" != "null" ] && [ "$response_text" != "Error: No response text found" ]; then
                log_success "Successfully received PR details response"
                echo "$response_text"
            else
                log_error "Unable to parse $MODEL_TYPE API response"
                log_debug "Response content:"
                cat "$temp_response" >&2
                rm -f "$temp_response"
                return 1
            fi
        else
            # Fallback if jq is not available - try basic text extraction
            local response_content
            response_content=$(cat "$temp_response")
            log_warning "jq not available - showing raw API response"
            echo "$response_content" >&2
        fi

        rm -f "$temp_response"
        return 0

    elif [ "$MODEL_TYPE" = "deepseek" ]; then
        # Deepseek API format (OpenAI compatible)
        log_debug "Using Deepseek format"
        cat > "$temp_payload" <<EOF
{
  "model": "deepseek-chat",
  "messages": [
    {
      "role": "user",
      "content": "$escaped_prompt"
    }
  ],
  "stream": false
}
EOF

        log_debug "Payload size: $(wc -c < "$temp_payload") bytes"

        # Make API call to Deepseek
        local start_time=$(date +%s)
        curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d @"$temp_payload" \
            "$API_URL" \
            > "$temp_response"

        local curl_exit_code=$?
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        rm -f "$temp_payload"

        if [ $curl_exit_code -ne 0 ]; then
            log_error "Failed to call $MODEL_TYPE API (curl exit code: $curl_exit_code)"
            rm -f "$temp_response"
            return 1
        fi

        log_debug "API response received in ${duration}s"

        # Extract text from response using dynamic parser
        if command -v jq >/dev/null 2>&1; then
            local response_text
            response_text=$(jq -r "$RESPONSE_PARSER // \"Error: No response text found\"" "$temp_response" 2>/dev/null)
            if [ "$response_text" != "null" ] && [ "$response_text" != "Error: No response text found" ]; then
                log_success "Successfully received PR details response"
                echo "$response_text"
            else
                log_error "Unable to parse $MODEL_TYPE API response"
                log_debug "Response content:"
                cat "$temp_response" >&2
                rm -f "$temp_response"
                return 1
            fi
        else
            # Fallback if jq is not available - try basic text extraction
            local response_content
            response_content=$(cat "$temp_response")
            log_warning "jq not available - showing raw API response"
            echo "$response_content" >&2
        fi

        rm -f "$temp_response"
        return 0
    else
        log_error "Unknown model type: $MODEL_TYPE"
        rm -f "$temp_payload" "$temp_response"
        return 1
    fi
}

# Function to load prompt template from external file
load_prompt_template() {
    if [ ! -f "$PROMPT_TEMPLATE_FILE" ]; then
        log_error "Prompt template file not found at: $PROMPT_TEMPLATE_FILE"
        log_error "Make sure the pr_details_prompt_template.txt file exists in the hooks directory"
        exit 1
    fi

    log_debug "Loading prompt template from: $PROMPT_TEMPLATE_FILE"
    cat "$PROMPT_TEMPLATE_FILE"
}

# Function to generate PR details from diff content
generate_pr_details() {
    local diff_content="$1"
    local branch_name="$2"

    # Load the prompt template from external file
    log_info "Loading PR details prompt template..."
    PR_DETAILS_PROMPT=$(load_prompt_template)

    # Create the full prompt
    FULL_PROMPT="The git diff is:


    $diff_content


    $PR_DETAILS_PROMPT"

    # Call AI API
    PR_DETAILS_RESULT=$(call_ai_api "$FULL_PROMPT")

    if [ $? -ne 0 ]; then
        log_error "Failed to generate PR details"
        return 1
    fi

    # Save the result to a markdown file
    FILENAME="PR_DETAILS_$(echo $branch_name | sed 's/\//_/g')_$(date +%Y%m%d%H%M%S).md"
    echo "$PR_DETAILS_RESULT" > "$FILENAME"

    log_success "PR details saved to: $FILENAME"
    return 0
}

# Determine the base branch according to the branch naming convention.
get_env_base_branch() {
    local branch_name="$1"

    if [[ "$branch_name" == *"/ci/"* ]]; then
        echo "master"
    elif [[ "$branch_name" == *"/dev/"* ]]; then
        echo "development"
    elif [[ "$branch_name" == *"/release/"* ]]; then
        echo "release"
    else
        echo ""
    fi
}

# Resolve a branch name to a ref that exists locally (or on origin).
resolve_branch_ref() {
    local branch="$1"

    if [ -z "$branch" ]; then
        return 1
    fi

    if git rev-parse --verify --quiet "$branch" >/dev/null 2>&1; then
        echo "$branch"
        return 0
    fi

    if git rev-parse --verify --quiet "origin/$branch" >/dev/null 2>&1; then
        echo "origin/$branch"
        return 0
    fi

    return 1
}

# ============================================================================
# MAIN LOGIC
# ============================================================================

# Check if SKIP_PR_DETAILS flag is set
if [ "${SKIP_PR_DETAILS:-false}" = true ]; then
    log_info "SKIP_PR_DETAILS flag detected - skipping PR details generation"
    exit 0
fi

log_section "PR DETAILS GENERATION"

# Check if API key is configured
if [ -z "$API_KEY" ]; then
    log_error "Could not read API_KEY from $MODEL_INI_FILE"
    log_error "Please ensure the model config file exists in $RESOURCES_DIR and contains 'api_key = your-key'"
    exit 1
fi

log_success "API key configured"

# Check dependencies
check_dependencies

# Check if we're being called from pre-push hook (with stdin) or standalone
# Read from stdin (if available from pre-push hook)
refs_input=$(cat)

if [ -n "$refs_input" ]; then
    log_debug "Processing refs from pre-push hook stdin"

    # Process refs from stdin (traditional post-push behavior)
    processed_count=0
    while read local_ref local_sha remote_ref remote_sha; do
        # Skip empty lines
        if [ -z "$local_ref" ]; then
            continue
        fi

        log_debug "Processing ref: $local_ref ($local_sha -> $remote_sha)"

        # We only care about branches, not tags
        if [[ $local_ref != refs/heads/* ]]; then
            log_debug "Skipping non-branch ref: $local_ref"
            continue
        fi

        # Get the range of commits that were pushed
        # If the remote branch was deleted, we can't get a diff
        if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
            log_warning "Branch was deleted, skipping"
            continue
        fi

        # If the remote branch is new, diff against the parent of the first commit
        if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
            remote_sha=$(git rev-parse $local_sha^1 2>/dev/null)
            log_info "New branch detected, comparing against parent commit"
        fi

        # Get branch name for logging and filename purposes
        BRANCH_NAME=$(echo "$local_ref" | sed 's/refs\/heads\///')

        BASE_BRANCH_NAME=$(get_env_base_branch "$BRANCH_NAME")
        BASE_BRANCH_REF=""
        if [ -n "$BASE_BRANCH_NAME" ]; then
            if BASE_BRANCH_REF=$(resolve_branch_ref "$BASE_BRANCH_NAME" 2>/dev/null); then
                log_info "Branch '$BRANCH_NAME' uses base '$BASE_BRANCH_NAME' - comparing against $BASE_BRANCH_REF"
            else
                log_warning "Base branch '$BASE_BRANCH_NAME' not found locally - falling back to push range"
                BASE_BRANCH_REF=""
            fi
        fi

        if [ -n "$BASE_BRANCH_REF" ]; then
            log_info "Generating diff for range: $BASE_BRANCH_REF..${local_sha:0:8}"
            DIFF_CONTENT=$(git diff "$BASE_BRANCH_REF" "$local_sha" 2>/dev/null)
        else
            log_info "Generating diff for range: ${remote_sha:0:8}..${local_sha:0:8}"
            DIFF_CONTENT=$(git diff "$remote_sha" "$local_sha" 2>/dev/null)
        fi

        if [ -z "$DIFF_CONTENT" ]; then
            log_warning "No changes detected in this push - skipping PR details generation"
            continue
        fi

        # Generate PR details
        generate_pr_details "$DIFF_CONTENT" "$BRANCH_NAME"
        ((processed_count++))
    done <<< "$refs_input"

    if [ $processed_count -eq 0 ]; then
        log_warning "No valid refs were processed from stdin"
    else
        log_section "PR DETAILS GENERATION COMPLETED"
        log_success "Total files generated: $processed_count"
    fi
else
    # Called standalone or from pre-push without refs - use current commit
    log_debug "No stdin input detected - using current HEAD commit"

    # Verify we have a valid commit
    if ! git rev-parse --verify HEAD >/dev/null 2>&1; then
        log_warning "No commits available for PR details generation"
        exit 0
    fi

    CURRENT_COMMIT=$(git rev-parse HEAD)
    BRANCH_NAME=$(git branch --show-current 2>/dev/null || echo "detached")

    log_info "Generating PR details for current commit: ${CURRENT_COMMIT:0:8}"
    log_info "Branch: $BRANCH_NAME"

    BASE_BRANCH_NAME=$(get_env_base_branch "$BRANCH_NAME")
    BASE_BRANCH_REF=""
    if [ -n "$BASE_BRANCH_NAME" ]; then
        if BASE_BRANCH_REF=$(resolve_branch_ref "$BASE_BRANCH_NAME" 2>/dev/null); then
            log_info "Branch '$BRANCH_NAME' uses base '$BASE_BRANCH_NAME' - comparing against $BASE_BRANCH_REF"
        else
            log_warning "Base branch '$BASE_BRANCH_NAME' not found locally - continuing with default comparison"
            BASE_BRANCH_REF=""
        fi
    fi

    # Try to get remote tracking branch
    REMOTE_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)

    if [ -n "$BASE_BRANCH_REF" ]; then
        log_info "Comparing against resolved base branch: $BASE_BRANCH_REF"
        DIFF_CONTENT=$(git diff "$BASE_BRANCH_REF" "$CURRENT_COMMIT")
    elif [ -n "$REMOTE_BRANCH" ]; then
        # Diff against remote tracking branch
        log_info "Comparing against remote tracking branch: $REMOTE_BRANCH"
        DIFF_CONTENT=$(git diff "$REMOTE_BRANCH" HEAD)
    else
        # Fallback to parent commit
        log_info "No remote tracking branch found - comparing against parent commit"
        PARENT_COMMIT=$(git rev-parse HEAD^1 2>/dev/null)
        if [ -n "$PARENT_COMMIT" ]; then
            DIFF_CONTENT=$(git diff "$PARENT_COMMIT" HEAD)
        else
            # Initial commit - diff against empty tree
            EMPTY_TREE=$(git hash-object -t tree /dev/null)
            DIFF_CONTENT=$(git diff "$EMPTY_TREE" HEAD)
        fi
    fi

    if [ -z "$DIFF_CONTENT" ]; then
        log_warning "No changes detected - skipping PR details generation"
        exit 0
    fi

    # Generate PR details
    generate_pr_details "$DIFF_CONTENT" "$BRANCH_NAME"

    log_section "PR DETAILS GENERATION COMPLETED"
    log_success "File generated successfully"
fi
