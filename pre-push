#!/bin/bash
#
# Standalone pre-push hook to review code changes before pushing.
# Called by "git push" before the push is executed.
# This hook performs AI code review using Gemini API in pure bash.
#
# To enable this hook, copy this file to .git/hooks/pre-push and make it executable:
# cp pre-push .git/hooks/
# cp prompt_template.txt .git/hooks/
# chmod +x .git/hooks/pre-push
#
# SKIP_AI flag usage:
# SKIP_AI=10 git push  # Skip only AI review
# SKIP_AI=01 git push  # Skip only PR details generation
# SKIP_AI=11 git push  # Skip both AI review and PR details

# ============================================================================
# CONFIGURATION - MODIFY THESE VALUES
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INI_FILE="$SCRIPT_DIR/gemini.ini"

# Read API key and URL from gemini.ini
GEMINI_API_KEY=$(grep -E '^api_key\s*=' "$INI_FILE" | sed -e 's/api_key\s*=\s*//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
GEMINI_API_URL=$(grep -E '^api_url\s*=' "$INI_FILE" | sed -e 's/api_url\s*=\s*//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

# Minimum number of changes required for review (default: 1)
MIN_CHANGES=15
PROMPT_TEMPLATE_FILE="$SCRIPT_DIR/prompt_templates/review_prompt_template.txt"

# ============================================================================
# LOGGING CONFIGURATION
# ============================================================================

# Color codes for better log visibility
COLOR_RESET='\033[0m'
COLOR_INFO='\033[0;36m'      # Cyan
COLOR_SUCCESS='\033[0;32m'   # Green
COLOR_WARNING='\033[0;33m'   # Yellow
COLOR_ERROR='\033[0;31m'     # Red
COLOR_DEBUG='\033[0;90m'     # Gray

# Log functions
log_info() {
    echo -e "${COLOR_INFO}[INFO]${COLOR_RESET} $1"
}

log_success() {
    echo -e "${COLOR_SUCCESS}[SUCCESS]${COLOR_RESET} $1"
}

log_warning() {
    echo -e "${COLOR_WARNING}[WARNING]${COLOR_RESET} $1"
}

log_error() {
    echo -e "${COLOR_ERROR}[ERROR]${COLOR_RESET} $1"
}

log_debug() {
    echo -e "${COLOR_DEBUG}[DEBUG]${COLOR_RESET} $1"
}

log_section() {
    echo ""
    echo -e "${COLOR_INFO}════════════════════════════════════════════════════════════════${COLOR_RESET}"
    echo -e "${COLOR_INFO}  $1${COLOR_RESET}"
    echo -e "${COLOR_INFO}════════════════════════════════════════════════════════════════${COLOR_RESET}"
}

# ============================================================================
# SKIP FLAGS HANDLING
# ============================================================================

# Parse SKIP_AI flag
# SKIP_AI=10 -> Skip review only
# SKIP_AI=01 -> Skip PR details only
# SKIP_AI=11 -> Skip both
SKIP_REVIEW=false
SKIP_PR_DETAILS=false

if [ -n "${SKIP_AI:-}" ]; then
    case "$SKIP_AI" in
        10)
            SKIP_REVIEW=true
            log_warning "SKIP_AI=10 detected - AI review will be skipped"
            ;;
        01)
            SKIP_PR_DETAILS=true
            log_warning "SKIP_AI=01 detected - PR details generation will be skipped"
            ;;
        11)
            SKIP_REVIEW=true
            SKIP_PR_DETAILS=true
            log_warning "SKIP_AI=11 detected - Both AI review and PR details will be skipped"
            ;;
        *)
            log_error "Invalid SKIP_AI value: $SKIP_AI (valid values: 10, 01, 11)"
            exit 1
            ;;
    esac
fi

# Support legacy SKIP_AI_REVIEW flag
if [ -n "${SKIP_AI_REVIEW:-}" ]; then
    SKIP_REVIEW=true
    log_warning "SKIP_AI_REVIEW detected (legacy flag) - AI review will be skipped"
fi

# ============================================================================
# FUNCTIONS
# ============================================================================

# Function to check if required tools are available
check_dependencies() {
    log_info "Checking dependencies..."

    if ! command -v curl >/dev/null 2>&1; then
        log_error "curl is required but not installed"
        exit 1
    fi
    log_debug "curl: ✓ Found"

    if ! command -v jq >/dev/null 2>&1; then
        log_warning "jq is not installed - JSON response formatting will be limited"
    else
        log_debug "jq: ✓ Found"
    fi
}

# Function to determine the target branch based on current branch name
get_target_branch() {
    local current_branch
    current_branch=$(git branch --show-current 2>/dev/null)

    if [ -z "$current_branch" ]; then
        echo ""
        return
    fi

    # Convert to lowercase for pattern matching
    local branch_lower
    branch_lower=$(echo "$current_branch" | tr '[:upper:]' '[:lower:]')

    # Check patterns in order of precedence
    case "$branch_lower" in
        *dev*|*development*) 
            echo "development"
            ;; 
        *ci*|*master*) 
            echo "master"
            ;; 
        *release*|*prod*|*production*) 
            echo "release"
            ;; 
        *)
            echo ""
            ;; 
    esac
}

# Function to get the git diff
get_git_diff() {
    local commit_hash="$1"
    local target_branch
    target_branch=$(get_target_branch)

    if [ -n "$target_branch" ]; then
        # Check if target branch exists
        if git rev-parse --verify "$target_branch" >/dev/null 2>&1; then
            log_info "Comparing against target branch: $target_branch"
            git diff "$target_branch" "$commit_hash"
        else
            log_warning "Target branch '$target_branch' not found, falling back to parent commit"
            get_git_diff_fallback "$commit_hash"
        fi
    else
        log_debug "No target branch pattern detected, using parent commit"
        get_git_diff_fallback "$commit_hash"
    fi
}

# Fallback function for git diff using parent commit
get_git_diff_fallback() {
    local commit_hash="$1"
    local parent_hash

    # Get parent commit hash
    parent_hash=$(git rev-parse "$commit_hash^" 2>/dev/null)
    if [ $? -ne 0 ]; then
        # This is likely the initial commit
        parent_hash=$(git hash-object -t tree /dev/null)
    fi

    # Generate diff between parent and current commit
    git diff "$parent_hash" "$commit_hash"
}

# Function to count changes in diff
count_changes() {
    local diff_content="$1"
    echo "$diff_content" | grep -c "^+" || echo "0"
}

# Function to check if commit has minimum changes
has_minimum_changes() {
    local diff_content="$1"
    local change_count
    change_count=$(count_changes "$diff_content")

    log_info "Found $change_count added lines"

    if [ "$change_count" -lt "$MIN_CHANGES" ]; then
        log_warning "Skipping AI review: Not enough changes ($change_count < $MIN_CHANGES)"
        return 1
    fi

    log_success "Change count meets minimum threshold ($change_count >= $MIN_CHANGES)"
    return 0
}

# Function to filter relevant files (similar to lambda logic)
is_relevant_file() {
    local file_path="$1"

    # Skip files containing 'enum', 'constant', or ending with .yml
    case "$file_path" in
        *enum*|*constant*|*.yml)
            return 1
            ;; 
        *)
            return 0
            ;; 
    esac
}

# Function to filter the diff content to only include relevant files
filter_diff_content() {
    local diff_content="$1"
    local filtered_diff=""
    local include_line=false
    local current_file=""
    local included_count=0
    local skipped_count=0

    log_info "Filtering relevant files..."

    while IFS= read -r line; do
        line=${line%$'\r'}
        if [[ "$line" =~ ^diff\ --git ]]; then
            # Extract file path from diff header
            current_file=$(echo "$line" | sed 's/^diff --git a\/\(.*\) b\/.*$/\1/')
            if is_relevant_file "$current_file"; then
                include_line=true
                log_debug "  ✓ Including: $current_file"
                filtered_diff+="$line"$'\n'
                ((included_count++))
            else
                include_line=false
                log_debug "  ✗ Skipping: $current_file"
                ((skipped_count++))
            fi
        elif [[ "$include_line" == true ]]; then
            filtered_diff+="$line"$'\n'
        fi
    done <<< "$diff_content"

    log_info "File filtering complete: $included_count included, $skipped_count skipped"
    echo "$filtered_diff"
}

# Function to escape JSON strings
escape_json() {
    local input="$1"
    # Escape backslashes, quotes, and newlines for JSON
    echo "$input" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g'
}

# Function to call Gemini API
call_gemini_api() {
    local prompt="$1"
    local temp_response="/tmp/gemini_response_$$.json"
    local temp_payload="/tmp/gemini_payload_$$.json"

    log_info "Calling Gemini API for code review..."
    log_debug "Using model: gemini-2.5-pro"

    # Escape the prompt for JSON
    local escaped_prompt
    escaped_prompt=$(escape_json "$prompt")

    # Create JSON payload
    cat > "$temp_payload" <<EOF
{
  "contents": [
    {
      "parts": [
        {
          "text": "$escaped_prompt"
        }
      ]
    }
  ]
}
EOF

    log_debug "Payload size: $(wc -c < "$temp_payload") bytes"

    # Make API call to Gemini
    local start_time=$(date +%s)
    curl -s -X POST \
        -H "Content-Type: application/json" \
        -d @"$temp_payload" \
        "$GEMINI_API_URL?key=$GEMINI_API_KEY" \
        > "$temp_response"

    local curl_exit_code=$?
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    rm -f "$temp_payload"

    if [ $curl_exit_code -ne 0 ]; then
        log_error "Failed to call Gemini API (curl exit code: $curl_exit_code)"
        rm -f "$temp_response"
        return 1
    fi

    log_debug "API response received in ${duration}s"

    # Extract text from response
    if command -v jq >/dev/null 2>&1; then
        local response_text
        response_text=$(jq -r '.candidates[0].content.parts[0].text // "Error: No response text found"' "$temp_response" 2>/dev/null)
        if [ "$response_text" != "null" ] && [ "$response_text" != "Error: No response text found" ]; then
            log_success "Successfully received AI review response"
            echo "$response_text"
        else
            log_error "Unable to parse Gemini API response"
            log_debug "Response content:"
            cat "$temp_response" >&2
            rm -f "$temp_response"
            return 1
        fi
    else
        # Fallback if jq is not available - try basic text extraction
        local response_content
        response_content=$(cat "$temp_response")
        log_warning "jq not available - showing raw API response"
        echo "$response_content" >&2
    fi

    rm -f "$temp_response"
    return 0
}

# Function to load prompt template from external file
load_prompt_template() {
    if [ ! -f "$PROMPT_TEMPLATE_FILE" ]; then
        log_error "Prompt template file not found at: $PROMPT_TEMPLATE_FILE"
        log_error "Make sure the prompt_template.txt file exists in the hooks directory"
        exit 1
    fi

    log_debug "Loading prompt template from: $PROMPT_TEMPLATE_FILE"
    cat "$PROMPT_TEMPLATE_FILE"
}

# Function to check if analysis shows no issues
has_no_issues() {
    local comment="$1"

    # Check for issues in critical sections.
    # We grep for the section header, then look at the next few lines.
    # If any of these sections contain something other than "No se encontraron problemas", we have an issue.
    if ! echo "$comment" | grep -A 3 "## Posibles Bugs" | grep -q "_No se encontraron problemas_"; then return 1; fi
    if ! echo "$comment" | grep -A 3 "## Posibles problemas de Diseño / SOLID" | grep -q "_No se encontraron problemas_"; then return 1; fi
    if ! echo "$comment" | grep -A 3 "## Posibles problemas de Clean Code" | grep -q "_No se encontraron problemas_"; then return 1; fi
    if ! echo "$comment" | grep -A 3 "## Violaciones de lineamientos REST" | grep -q "_No se encontraron problemas_"; then return 1; fi
    if ! echo "$comment" | grep -A 3 "## Violaciones de lineamientos de Swagger" | grep -q "_No se encontraron problemas_"; then return 1; fi

    # If we've gotten this far, it means all critical sections are clean.
    return 0
}

# ============================================================================
# MAIN LOGIC
# ============================================================================

# Capture stdin for post-push
pushed_refs=$(cat)

log_section "PRE-PUSH AI CODE REVIEW"

# Check if we should skip both
if [ "$SKIP_REVIEW" = true ] && [ "$SKIP_PR_DETAILS" = true ]; then
    log_info "Skipping all AI processing"
    exit 0
fi

# Check if we should skip only the review
if [ "$SKIP_REVIEW" = true ]; then
    log_info "Skipping AI review - proceeding to PR details generation"
    POST_PUSH_SCRIPT="$SCRIPT_DIR/pr-details"
    if [ -f "$POST_PUSH_SCRIPT" ] && [ "$SKIP_PR_DETAILS" = false ]; then
        log_section "PR DETAILS GENERATION"
        SKIP_PR_DETAILS=$SKIP_PR_DETAILS "$POST_PUSH_SCRIPT" <<< "$pushed_refs"
    fi
    exit 0
fi

# Check if API key is configured
if [ -z "$GEMINI_API_KEY" ]; then
    log_error "Could not read GEMINI_API_KEY from gemini.ini"
    log_error "Please ensure gemini.ini exists in $SCRIPT_DIR and contains 'api_key = your-key'"
    exit 1
fi

log_success "API key configured"

# Check dependencies
check_dependencies

# Verify we have a valid commit
if ! git rev-parse --verify HEAD >/dev/null 2>&1; then
    log_warning "No commits to review yet"
    exit 0
fi

# Get the current commit hash
CURRENT_COMMIT=$(git rev-parse HEAD)
log_info "Reviewing commit: ${CURRENT_COMMIT:0:8}"

# Get commit message for context
COMMIT_MESSAGE=$(git log -1 --pretty=format:"%s" "$CURRENT_COMMIT")
log_info "Commit message: $COMMIT_MESSAGE"

# Get the diff for the current commit
log_info "Generating diff..."
DIFF_CONTENT=$(get_git_diff "$CURRENT_COMMIT")

if [ -z "$DIFF_CONTENT" ]; then
    log_warning "No changes detected in this commit - skipping review"
    exit 0
fi

# Check if there are enough changes to warrant review
if ! has_minimum_changes "$DIFF_CONTENT"; then
    # Still run PR details if not skipped
    POST_PUSH_SCRIPT="$SCRIPT_DIR/pr-details"
    if [ -f "$POST_PUSH_SCRIPT" ] && [ "$SKIP_PR_DETAILS" = false ]; then
        log_section "PR DETAILS GENERATION"
        SKIP_PR_DETAILS=$SKIP_PR_DETAILS "$POST_PUSH_SCRIPT" <<< "$pushed_refs"
    fi
    exit 0
fi

# Filter diff to only include relevant files
FILTERED_DIFF=$(filter_diff_content "$DIFF_CONTENT")

# If no relevant files, skip review
if [ -z "$FILTERED_DIFF" ]; then
    log_warning "No relevant files found for review - skipping"
    # Still run PR details if not skipped
    POST_PUSH_SCRIPT="$SCRIPT_DIR/pr-details"
    if [ -f "$POST_PUSH_SCRIPT" ] && [ "$SKIP_PR_DETAILS" = false ]; then
        log_section "PR DETAILS GENERATION"
        SKIP_PR_DETAILS=$SKIP_PR_DETAILS "$POST_PUSH_SCRIPT" <<< "$pushed_refs"
    fi
    exit 0
fi

# Load the prompt template from external file
log_info "Loading review prompt template..."
PR_REVIEW_PROMPT=$(load_prompt_template)

# Create the full prompt
FULL_PROMPT="The PR diff is:
\`\`\`diff
$FILTERED_DIFF
\`\`\`

$PR_REVIEW_PROMPT"

# Call Gemini API
REVIEW_RESULT=$(call_gemini_api "$FULL_PROMPT")

if [ $? -ne 0 ]; then
    log_error "Failed to get AI review"
    exit 1
fi

# Display results
log_section "AI CODE REVIEW RESULTS"
echo "$REVIEW_RESULT"

# Execute PR details script if not skipped
POST_PUSH_SCRIPT="$SCRIPT_DIR/pr-details"
if [ -f "$POST_PUSH_SCRIPT" ] && [ "$SKIP_PR_DETAILS" = false ]; then
    log_section "PR DETAILS GENERATION"
    SKIP_PR_DETAILS=$SKIP_PR_DETAILS "$POST_PUSH_SCRIPT" <<< "$pushed_refs"
fi

# Check if there are no issues
if has_no_issues "$REVIEW_RESULT"; then
    echo ""
    log_success "✅ No issues found in the code review! Proceeding with push."
    echo ""
else
    echo ""
    log_error "⚠️  Issues found in the code review. Please review the feedback above."
    log_error "*** PUSH REJECTED BY AI CODE REVIEW ***"
    log_info "To bypass this check, use: SKIP_AI=10 git push"
    echo ""
    # Exit with 1 to block the push
    exit 1
fi

log_section "PRE-PUSH REVIEW COMPLETED"