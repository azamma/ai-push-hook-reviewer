#!/bin/bash
#
# Standalone pre-push hook to review code changes before pushing.
# Called by "git push" before the push is executed.
# This hook performs AI code review using Gemini API in pure bash.
#
# To enable this hook, copy this file to .git/hooks/pre-push and make it executable:
# cp pre-push .git/hooks/
# cp prompt_template.txt .git/hooks/
# chmod +x .git/hooks/pre-push
#
# SKIP flag usage:
# SKIP=10 git push  # Skip only AI review
# SKIP=01 git push  # Skip only PR details generation
# SKIP=11 git push  # Skip both AI review and PR details

# ============================================================================
# CONFIGURATION - MODIFY THESE VALUES
# ============================================================================

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RESOURCES_DIR="$SCRIPT_DIR/pre-push-resources"
AI_MODELS_CONFIG="$RESOURCES_DIR/ai-models.yml"

# Model selection (default: 1=Gemini, can be overridden with MODEL env variable)
MODEL=${MODEL:-1}

# Parse YAML model configuration using bash + grep (no external deps)
parse_yaml_model() {
    local model_id="$1"
    local config_file="$2"
    local key="$3"

    # Find the model block and extract the key value
    awk -v id="$model_id" -v k="$key" '
        /^models:/ { in_models=1; next }
        in_models && /^  - id: / {
            current_id=$NF
            if (current_id == id) { found=1 }
        }
        found && /^  - id: / && current_id != id { found=0 }
        found && $0 ~ "^    " k ": " {
            # Extract value after the key
            match($0, /^    [^:]+: (.*)$/, arr)
            gsub(/["'"'"']/, "", arr[1])  # Remove quotes
            print arr[1]
            exit
        }
    ' "$config_file"
}

# Load model configuration from YAML
load_model_config() {
    local model_num="$1"

    if [ ! -f "$AI_MODELS_CONFIG" ]; then
        log_error "Model configuration file not found at: $AI_MODELS_CONFIG"
        exit 1
    fi

    # Parse YAML for model details
    local model_type
    local model_config_file
    local response_parser

    model_type=$(parse_yaml_model "$model_num" "$AI_MODELS_CONFIG" "type")
    model_config_file=$(parse_yaml_model "$model_num" "$AI_MODELS_CONFIG" "config_file")
    response_parser=$(parse_yaml_model "$model_num" "$AI_MODELS_CONFIG" "response_parser")

    if [ -z "$model_type" ] || [ -z "$model_config_file" ]; then
        log_error "Model $model_num not found in configuration"
        exit 1
    fi

    local model_ini_file="$RESOURCES_DIR/$model_config_file"

    if [ ! -f "$model_ini_file" ]; then
        log_error "Model config file not found at: $model_ini_file"
        exit 1
    fi

    echo "$model_ini_file:$model_type:$response_parser"
}

# Get model configuration
MODEL_CONFIG=$(load_model_config "$MODEL")
MODEL_INI_FILE="${MODEL_CONFIG%%:*}"
MODEL_TYPE="${MODEL_CONFIG#*:}"
MODEL_TYPE="${MODEL_TYPE%%:*}"
RESPONSE_PARSER="${MODEL_CONFIG##*:}"

log_debug "Using MODEL=$MODEL ($MODEL_TYPE)"

# Read API key and URL from the selected model config
API_KEY=$(grep -E '^api_key\s*=' "$MODEL_INI_FILE" | sed -e 's/api_key\s*=\s*//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
API_URL=$(grep -E '^api_url\s*=' "$MODEL_INI_FILE" | sed -e 's/api_url\s*=\s*//' -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

# Minimum number of changes required for review (default: 1)
MIN_CHANGES=15
PROMPT_TEMPLATE_FILE="$RESOURCES_DIR/prompt_templates/review_prompt_template.txt"

# ============================================================================
# LOGGING CONFIGURATION
# ============================================================================

# Color codes for better log visibility
COLOR_RESET='\033[0m'
COLOR_INFO='\033[0;36m'      # Cyan
COLOR_SUCCESS='\033[0;32m'   # Green
COLOR_WARNING='\033[0;33m'   # Yellow
COLOR_ERROR='\033[0;31m'     # Red
COLOR_DEBUG='\033[0;90m'     # Gray

# Log functions
log_info() {
    echo -e "${COLOR_INFO}[INFO]${COLOR_RESET} $1" >&2
}

log_success() {
    echo -e "${COLOR_SUCCESS}[SUCCESS]${COLOR_RESET} $1" >&2
}

log_warning() {
    echo -e "${COLOR_WARNING}[WARNING]${COLOR_RESET} $1" >&2
}

log_error() {
    echo -e "${COLOR_ERROR}[ERROR]${COLOR_RESET} $1" >&2
}

log_debug() {
    echo -e "${COLOR_DEBUG}[DEBUG]${COLOR_RESET} $1" >&2
}

log_section() {
    echo "" >&2
    echo -e "${COLOR_INFO}════════════════════════════════════════════════════════════════${COLOR_RESET}" >&2
    echo -e "${COLOR_INFO}  $1${COLOR_RESET}" >&2
    echo -e "${COLOR_INFO}════════════════════════════════════════════════════════════════${COLOR_RESET}" >&2
}

# ============================================================================
# SKIP FLAGS HANDLING
# ============================================================================

# Parse SKIP flag
# SKIP=10 -> Skip review only
# SKIP=01 -> Skip PR details only
# SKIP=11 -> Skip both
SKIP_REVIEW=false
SKIP_PR_DETAILS=false

if [ -n "${SKIP:-}" ]; then
    case "$SKIP" in
        10)
            SKIP_REVIEW=true
            log_warning "SKIP=10 detected - AI review will be skipped"
            ;;
        01)
            SKIP_PR_DETAILS=true
            log_warning "SKIP=01 detected - PR details generation will be skipped"
            ;;
        11)
            SKIP_REVIEW=true
            SKIP_PR_DETAILS=true
            log_warning "SKIP=11 detected - Both AI review and PR details will be skipped"
            ;;
        *)
            log_error "Invalid SKIP value: $SKIP (valid values: 10, 01, 11)"
            exit 1
            ;;
    esac
fi

# Support legacy flags
if [ -n "${SKIP_AI:-}" ]; then
    log_warning "SKIP_AI is deprecated, please use SKIP instead"
    case "$SKIP_AI" in
        10) SKIP_REVIEW=true ;;
        01) SKIP_PR_DETAILS=true ;;
        11) SKIP_REVIEW=true; SKIP_PR_DETAILS=true ;;
    esac
fi

if [ -n "${SKIP_AI_REVIEW:-}" ]; then
    SKIP_REVIEW=true
    log_warning "SKIP_AI_REVIEW is deprecated, please use SKIP=10 instead"
fi

# ============================================================================
# FUNCTIONS
# ============================================================================

# Function to check if required tools are available
check_dependencies() {
    log_info "Checking dependencies..."

    if ! command -v curl >/dev/null 2>&1; then
        log_error "curl is required but not installed"
        exit 1
    fi
    log_debug "curl: ✓ Found"

    if ! command -v jq >/dev/null 2>&1; then
        log_warning "jq is not installed - JSON response formatting will be limited"
    else
        log_debug "jq: ✓ Found"
    fi
}

# Function to determine the target branch based on current branch name
get_target_branch() {
    local current_branch
    current_branch=$(git branch --show-current 2>/dev/null)

    if [ -z "$current_branch" ]; then
        echo ""
        return
    fi

    # Convert to lowercase for pattern matching
    local branch_lower
    branch_lower=$(echo "$current_branch" | tr '[:upper:]' '[:lower:]')

    # Check patterns in order of precedence
    case "$branch_lower" in
        *dev*|*development*) 
            echo "development"
            ;; 
        *ci*|*master*) 
            echo "master"
            ;; 
        *release*|*prod*|*production*) 
            echo "release"
            ;; 
        *)
            echo ""
            ;; 
    esac
}

# Function to get the git diff
get_git_diff() {
    local commit_hash="$1"
    local target_branch
    target_branch=$(get_target_branch)

    if [ -n "$target_branch" ]; then
        # Check if target branch exists
        if git rev-parse --verify "$target_branch" >/dev/null 2>&1; then
            log_info "Comparing against target branch: $target_branch"
            git diff "$target_branch" "$commit_hash"
        else
            log_warning "Target branch '$target_branch' not found, falling back to parent commit"
            get_git_diff_fallback "$commit_hash"
        fi
    else
        log_debug "No target branch pattern detected, using parent commit"
        get_git_diff_fallback "$commit_hash"
    fi
}

# Fallback function for git diff using parent commit
get_git_diff_fallback() {
    local commit_hash="$1"
    local parent_hash

    # Get parent commit hash
    parent_hash=$(git rev-parse "$commit_hash^" 2>/dev/null)
    if [ $? -ne 0 ]; then
        # This is likely the initial commit
        parent_hash=$(git hash-object -t tree /dev/null)
    fi

    # Generate diff between parent and current commit
    git diff "$parent_hash" "$commit_hash"
}

# Function to count changes in diff
count_changes() {
    local diff_content="$1"
    echo "$diff_content" | grep -c "^+" || echo "0"
}

# Function to check if commit has minimum changes
has_minimum_changes() {
    local diff_content="$1"
    local change_count
    change_count=$(count_changes "$diff_content")

    log_info "Found $change_count added lines"

    if [ "$change_count" -lt "$MIN_CHANGES" ]; then
        log_warning "Skipping AI review: Not enough changes ($change_count < $MIN_CHANGES)"
        return 1
    fi

    log_success "Change count meets minimum threshold ($change_count >= $MIN_CHANGES)"
    return 0
}

# Function to filter relevant files (similar to lambda logic)
is_relevant_file() {
    local file_path="$1"

    # Skip files containing 'enum', 'constant', or ending with .yml
    case "$file_path" in
        *enum*|*constant*|*.yml)
            return 1
            ;; 
        *)
            return 0
            ;; 
    esac
}

# Function to filter the diff content to only include relevant files
filter_diff_content() {
    local diff_content="$1"
    local filtered_diff=""
    local include_line=false
    local current_file=""
    local included_count=0
    local skipped_count=0

    log_info "Filtering relevant files..."

    while IFS= read -r line; do
        line=${line%$'\r'}
        if [[ "$line" =~ ^diff\ --git ]]; then
            # Extract file path from diff header
            current_file=$(echo "$line" | sed 's/^diff --git a\/\(.*\) b\/.*$/\1/')
            if is_relevant_file "$current_file"; then
                include_line=true
                log_debug "  ✓ Including: $current_file"
                filtered_diff+="$line"$'\n'
                ((included_count++))
            else
                include_line=false
                log_debug "  ✗ Skipping: $current_file"
                ((skipped_count++))
            fi
        elif [[ "$include_line" == true ]]; then
            filtered_diff+="$line"$'\n'
        fi
    done <<< "$diff_content"

    log_info "File filtering complete: $included_count included, $skipped_count skipped"
    echo "$filtered_diff"
}

# Function to escape JSON strings
escape_json() {
    local input="$1"
    # Escape backslashes, quotes, and newlines for JSON
    echo "$input" | sed 's/\\/\\\\/g' | sed 's/"/\\"/g' | sed ':a;N;$!ba;s/\n/\\n/g'
}

# Function to call AI API (Gemini or Deepseek)
call_ai_api() {
    local prompt="$1"
    local temp_response="/tmp/ai_response_$$.json"
    local temp_payload="/tmp/ai_payload_$$.json"

    log_info "Calling $MODEL_TYPE API for code review..."
    log_debug "Using model type: $MODEL_TYPE"

    # Escape the prompt for JSON
    local escaped_prompt
    escaped_prompt=$(escape_json "$prompt")

    if [ "$MODEL_TYPE" = "gemini" ]; then
        # Gemini API format
        log_debug "Using Gemini format"
        cat > "$temp_payload" <<EOF
{
  "contents": [
    {
      "parts": [
        {
          "text": "$escaped_prompt"
        }
      ]
    }
  ]
}
EOF

        log_debug "Payload size: $(wc -c < "$temp_payload") bytes"

        # Make API call to Gemini
        local start_time=$(date +%s)
        curl -s -X POST \
            -H "Content-Type: application/json" \
            -d @"$temp_payload" \
            "$API_URL?key=$API_KEY" \
            > "$temp_response"

        local curl_exit_code=$?
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        rm -f "$temp_payload"

        if [ $curl_exit_code -ne 0 ]; then
            log_error "Failed to call $MODEL_TYPE API (curl exit code: $curl_exit_code)"
            rm -f "$temp_response"
            return 1
        fi

        log_debug "API response received in ${duration}s"

        # Extract text from response using dynamic parser
        if command -v jq >/dev/null 2>&1; then
            local response_text
            response_text=$(jq -r "$RESPONSE_PARSER // \"Error: No response text found\"" "$temp_response" 2>/dev/null)
            if [ "$response_text" != "null" ] && [ "$response_text" != "Error: No response text found" ]; then
                log_success "Successfully received AI review response"
                echo "$response_text"
            else
                log_error "Unable to parse $MODEL_TYPE API response"
                log_debug "Response content:"
                cat "$temp_response" >&2
                rm -f "$temp_response"
                return 1
            fi
        else
            # Fallback if jq is not available - try basic text extraction
            local response_content
            response_content=$(cat "$temp_response")
            log_warning "jq not available - showing raw API response"
            echo "$response_content" >&2
        fi

        rm -f "$temp_response"
        return 0

    elif [ "$MODEL_TYPE" = "deepseek" ]; then
        # Deepseek API format (OpenAI compatible)
        log_debug "Using Deepseek format"
        cat > "$temp_payload" <<EOF
{
  "model": "deepseek-chat",
  "messages": [
    {
      "role": "user",
      "content": "$escaped_prompt"
    }
  ],
  "stream": false
}
EOF

        log_debug "Payload size: $(wc -c < "$temp_payload") bytes"

        # Make API call to Deepseek
        local start_time=$(date +%s)
        curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d @"$temp_payload" \
            "$API_URL" \
            > "$temp_response"

        local curl_exit_code=$?
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))
        rm -f "$temp_payload"

        if [ $curl_exit_code -ne 0 ]; then
            log_error "Failed to call $MODEL_TYPE API (curl exit code: $curl_exit_code)"
            rm -f "$temp_response"
            return 1
        fi

        log_debug "API response received in ${duration}s"

        # Extract text from response using dynamic parser
        if command -v jq >/dev/null 2>&1; then
            local response_text
            response_text=$(jq -r "$RESPONSE_PARSER // \"Error: No response text found\"" "$temp_response" 2>/dev/null)
            if [ "$response_text" != "null" ] && [ "$response_text" != "Error: No response text found" ]; then
                log_success "Successfully received AI review response"
                echo "$response_text"
            else
                log_error "Unable to parse $MODEL_TYPE API response"
                log_debug "Response content:"
                cat "$temp_response" >&2
                rm -f "$temp_response"
                return 1
            fi
        else
            # Fallback if jq is not available - try basic text extraction
            local response_content
            response_content=$(cat "$temp_response")
            log_warning "jq not available - showing raw API response"
            echo "$response_content" >&2
        fi

        rm -f "$temp_response"
        return 0
    else
        log_error "Unknown model type: $MODEL_TYPE"
        rm -f "$temp_payload" "$temp_response"
        return 1
    fi
}

# Function to load prompt template from external file
load_prompt_template() {
    if [ ! -f "$PROMPT_TEMPLATE_FILE" ]; then
        log_error "Prompt template file not found at: $PROMPT_TEMPLATE_FILE"
        log_error "Make sure the prompt_template.txt file exists in the hooks directory"
        exit 1
    fi

    log_debug "Loading prompt template from: $PROMPT_TEMPLATE_FILE"
    cat "$PROMPT_TEMPLATE_FILE"
}

# Function to check if analysis shows no issues
has_no_issues() {
    local comment="$1"

    # Check for issues in critical sections.
    # We grep for the section header, then look at the next few lines.
    # If any of these sections contain something other than "No se encontraron problemas", we have an issue.
    if ! echo "$comment" | grep -A 3 "## Posibles Bugs" | grep -q "_No se encontraron problemas_"; then return 1; fi
    if ! echo "$comment" | grep -A 3 "## Posibles problemas de Diseño / SOLID" | grep -q "_No se encontraron problemas_"; then return 1; fi
    if ! echo "$comment" | grep -A 3 "## Posibles problemas de Clean Code" | grep -q "_No se encontraron problemas_"; then return 1; fi
    if ! echo "$comment" | grep -A 3 "## Violaciones de lineamientos REST" | grep -q "_No se encontraron problemas_"; then return 1; fi
    if ! echo "$comment" | grep -A 3 "## Violaciones de lineamientos de Swagger" | grep -q "_No se encontraron problemas_"; then return 1; fi

    # If we've gotten this far, it means all critical sections are clean.
    return 0
}

# ============================================================================
# MAIN LOGIC
# ============================================================================

# Capture stdin for post-push
pushed_refs=$(cat)

log_section "PRE-PUSH AI CODE REVIEW by Zamma"

# Check if we should skip both
if [ "$SKIP_REVIEW" = true ] && [ "$SKIP_PR_DETAILS" = true ]; then
    log_info "Skipping all AI processing"
    exit 0
fi

# Check if we should skip only the review
if [ "$SKIP_REVIEW" = true ]; then
    log_info "Skipping AI review - proceeding to PR details generation"
    POST_PUSH_SCRIPT="$RESOURCES_DIR/pr-details"
    if [ -f "$POST_PUSH_SCRIPT" ] && [ "$SKIP_PR_DETAILS" = false ]; then
        echo "$pushed_refs" | SKIP_PR_DETAILS=$SKIP_PR_DETAILS "$POST_PUSH_SCRIPT"
    fi
    exit 0
fi

# Check if API key is configured
if [ -z "$API_KEY" ]; then
    log_error "Could not read API_KEY from $MODEL_INI_FILE"
    log_error "Please ensure the model config file exists in $RESOURCES_DIR and contains 'api_key = your-key'"
    exit 1
fi

log_success "API key configured"

# Check dependencies
check_dependencies

# Verify we have a valid commit
if ! git rev-parse --verify HEAD >/dev/null 2>&1; then
    log_warning "No commits to review yet"
    exit 0
fi

# Get the current commit hash
CURRENT_COMMIT=$(git rev-parse HEAD)
log_info "Reviewing commit: ${CURRENT_COMMIT:0:8}"

# Get commit message for context
COMMIT_MESSAGE=$(git log -1 --pretty=format:"%s" "$CURRENT_COMMIT")
log_info "Commit message: $COMMIT_MESSAGE"

# Get the diff for the current commit
log_info "Generating diff..."
DIFF_CONTENT=$(get_git_diff "$CURRENT_COMMIT")

if [ -z "$DIFF_CONTENT" ]; then
    log_warning "No changes detected in this commit - skipping review"
    exit 0
fi

# Check if there are enough changes to warrant review
if ! has_minimum_changes "$DIFF_CONTENT"; then
    # Still run PR details if not skipped
    POST_PUSH_SCRIPT="$RESOURCES_DIR/pr-details"
    if [ -f "$POST_PUSH_SCRIPT" ] && [ "$SKIP_PR_DETAILS" = false ]; then
        echo "$pushed_refs" | SKIP_PR_DETAILS=$SKIP_PR_DETAILS "$POST_PUSH_SCRIPT"
    fi
    exit 0
fi

# Filter diff to only include relevant files
FILTERED_DIFF=$(filter_diff_content "$DIFF_CONTENT")

# If no relevant files, skip review
if [ -z "$FILTERED_DIFF" ]; then
    log_warning "No relevant files found for review - skipping"
    # Still run PR details if not skipped
    POST_PUSH_SCRIPT="$RESOURCES_DIR/pr-details"
    if [ -f "$POST_PUSH_SCRIPT" ] && [ "$SKIP_PR_DETAILS" = false ]; then
        echo "$pushed_refs" | SKIP_PR_DETAILS=$SKIP_PR_DETAILS "$POST_PUSH_SCRIPT"
    fi
    exit 0
fi

# Load the prompt template from external file
log_info "Loading review prompt template..."
PR_REVIEW_PROMPT=$(load_prompt_template)

# Create the full prompt
FULL_PROMPT="The PR diff is:
\`\`\`diff
$FILTERED_DIFF
\`\`\`

$PR_REVIEW_PROMPT"

# Call AI API
REVIEW_RESULT=$(call_ai_api "$FULL_PROMPT")

if [ $? -ne 0 ]; then
    log_error "Failed to get AI review"
    exit 1
fi

# Display results
log_section "AI CODE REVIEW RESULTS"
echo "$REVIEW_RESULT"

# Execute PR details script if not skipped
POST_PUSH_SCRIPT="$RESOURCES_DIR/pr-details"
if [ -f "$POST_PUSH_SCRIPT" ] && [ "$SKIP_PR_DETAILS" = false ]; then
    echo "$pushed_refs" | SKIP_PR_DETAILS=$SKIP_PR_DETAILS "$POST_PUSH_SCRIPT"
fi

# Check if there are no issues
if has_no_issues "$REVIEW_RESULT"; then
    echo "" >&2
    log_success "✅ No issues found in the code review! Proceeding with push."
    echo "" >&2
else
    echo "" >&2
    log_error "⚠️  Issues found in the code review. Please review the feedback above."
    log_error "*** PUSH REJECTED BY AI CODE REVIEW ***"
    log_info "To bypass this check, use: SKIP=10 git push"
    echo "" >&2
    # Exit with 1 to block the push
    exit 1
fi

log_section "PRE-PUSH REVIEW COMPLETED"